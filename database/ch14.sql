-- #14-1 제약 조건 종류
/*
제약 조건이란?
 오라클에서 사용하는 제약 조건은 테이블의 특정 열에 지정한다.
 제약 조건을 지정한 열에 제약 조건에 부합하지 않는 데이터를 저장할 수 없다.
 
 NOT NULL : 지정한 열에 NULL을 허용하지 않음 NULL을 제외한 데이터의 중복은 허용됨
 UNIQUE : 지정한 열이 유일한 값을 가져야 함. 즉, 중복될 수 없음. 단 NULL은 값의 중복에서 제외됨
 PRIMARY KEY : 지정한 열이 유일한 값이면서 NULL을 허용하지 않음. PRIMARY KEY는 테이블에 하나만 지정 가능
 FOREIGN KET : 다른 테이블의 열을 참조하여 존재하는 값만 입력 가능
 CHECK : 설정한 조건식을 만족하는 데이터만 입력 가능

데이터 무결성이란?
 데이터 무결성(data integrity)은 데이터베이스에 저장되는 데이터의 정확성과 일관성을 보장한다는
 의미이며 이를 위해 항상 유지해야 하는 기본 규칙을 가지고 있습니다.
 제약 조건은 이러한 데이터 무결성을 지키기 위한 안전장치로서 중요한 역할을 한다.
*/

-- #14-2 빈값을 허락하지 않는 NOT NULL
-- 테이블을 생성할 때 NOT NULL 설정하기
CREATE TABLE TABLE_NOTNULL (
	LOGIN_ID	VARCHAR2(20) NOT NULL,
	LOGIN_PWD	VARCHAR2(20) NOT NULL,
	TEL			VARCHAR2(20)
);

DESC TABLE_NOTNULL;
-- 제약 조건이 NOT NULL인 열에 NULL 값 넣어보기
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', NULL, '010-1234-5678');

-- 제약 조건이 없는 TEL 열에 NULL 값 입력하기
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD)
VALUES('TEST_ID_01', '1234');

SELECT * FROM TABLE_NOTNULL;

-- NOT NULL 제약 조건이 지정된 열 데이터를 NULL 값으로 업데이트하기
UPDATE TABLE_NOTNULL
   SET LOGIN_PWD = NULL
 WHERE LOGIN_ID = 'TEST_ID_01';
 
-- 제약 조건 살펴보기(SCOTT 계정)
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;

-- 테이블을 생성할 때 제약 조건에 이름 지정하기
 CREATE TABLE TABLE_NOTNULL2(
 	LOGIN_ID	VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL,
 	LOGIN_PWD	VARCHAR2(20) CONSTRAINT TBLNN2_LGNPW_NN NOT NULL,
 	TEL			VARCHAR2(20)
 );

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
 
-- TEL 열에 NOT NULL 제약 조건 추가하기
ALTER TABLE TABLE_NOTNULL
MODIFY(TEL NOT NULL);

-- TEL 열 데이터 수정하기
UPDATE TABLE_NOTNULL
   SET TEL = '010-1234-5678'
 WHERE LOGIN_ID = 'TEST_ID_01';
 
SELECT * FROM TABLE_NOTNULL2;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
  
-- 제약 조건에 이름 지정해서 추가하기
ALTER TABLE TABLE_NOTNULL2
MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
  
 -- 이미 생성된 제약 조건 이름 변경하기
ALTER TABLE TABLE_NOTNULL2
RENAME CONSTRAINT TBLNN_TEL_NN TO TBLNN2_TEL_NN;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
  
-- 제약 조건 삭제하기
ALTER TABLE TABLE_NOTNULL2
DROP CONSTRAINT TBLNN2_TEL_NN;

-- 14-3 중복되지 않는 값 UNIQUE
-- 제약 조건 지정하기(테이블을 생성할 때)
CREATE TABLE TABLE_UNIQUE(
	LOGIN_ID	VARCHAR2(20) UNIQUE,
	LOGIN_PWD	VARCHAR2(20) NOT NULL,
	TEL			VARCHAR2(20)
);

-- USER_CONSTRAINTS 데이터 사전 뷰로 제약 조건 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME = 'TABLE_UNIQUE';
 
-- TABLE_UNIQUE 테이블에 데이터 입력하기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

-- TABLE_UNIQUE 테이블에 데이터 입력하기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_02', 'PWD01', '010-1234-5678');

-- UNIQUE 제약 조건이 지정된 열에 NULL 값 입력하기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES(NULL, 'PWD01', '010-2345-6789');

-- TABLE_UNIQUE 테이블 데이터 수정하기
UPDATE TABLE_UNIQUE
   SET LOGIN_ID = 'TEST_ID_01'
 WHERE LOGIN_ID IS NULL;


SELECT * FROM TABLE_UNIQUE;

-- 테이블을 생성할 때 UNIQUE 제약 조건 설정하기
CREATE TABLE TABLE_UNIQUE2(
	LOGIN_ID	VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNID_UNQ UNIQUE,
	LOGIN_PWD	VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNPW_NN NOT NULL,
	TEL			VARCHAR2(20)
);

-- 생성한 UNIQUE 제약 조건 확인하기(USER_CONSTRAINTS 사용)
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
 
-- 이미 생성한 테이블 열에 UNIQUE 제약 조건 추가하기
ALTER TABLE TABLE_UNIQUE
MODIFY(TEL UNIQUE);

-- TEL 열 값을 모두 NULL 값으로 변경하기
UPDATE TABLE_UNIQUE
   SET TEL = NULL;
   
-- UNIQUE 제약 조건 이름 직접 지정하기
ALTER TABLE TABLE_UNIQUE2
MODIFY(TEL CONSTRAINT TBLUNQ_TEL_UNQ UNIQUE);
  
-- 이미 만들어져 있는 UNIQUE 제약 조건 이름 수정하기
ALTER TABLE TABLE_UNIQUE2
RENAME CONSTRAINT TBLUNQ_TEL_UNQ TO TBLUNQ2_TEL_UNQ;

-- 제약 조건 삭제하기
ALTER TABLE TABLE_UNIQUE2
DROP CONSTRAINT TBLUNQ2_TEL_UNQ;

SELECT * FROM TABLE_UNIQUE;

-- # 14-4 유일하게 하나만 있는 값 PRIMARY KEY
/*
PRIMARY KEY 제약 조건은 UNIQUE와 NOT NULL 제약 조건의 특성을 모두 가지는 제약 조건입니다.
즉 데이터의 중복을 허용하지 않고 NULL도 허용하지 않습니다.
NULL이 아닌 유일한 값을 가지므로 주민등록번호나 EMP 테이블의 사원 번호같이 테이블의 각 행을 식별하는 데 활용됩니다.
PRIMARY KEY 제약 조건은 테이블에 하나밖에 지정할 수 없습니다.
그리고 특정 열을 PRIMARY KEY로 지정하면 해당 열에는 자동으로 인덱스가 만들어집니다.
*/
-- 테이블을 생성할 때 특정 열에 PRIMARY KEY 설정하기
CREATE TABLE TABLE_PK(
	LOGIN_ID	VARCHAR2(20) PRIMARY KEY,
	LOGIN_PWD	VARCHAR2(20) NOT NULL,
	TEL			VARCHAR2(20)
);

-- 생성한 PRIMARY KEY 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_PK%';

-- 생성한 PRIMARY KEY를 통해 자동 생성된 INDEX 확인하기
SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME
  FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'TABLE_PK%';

-- 제약 조건의 이름을 직접 지정하여 테이블 생성하기
CREATE TABLE TABLE_PK2(
	LOGIN_ID	VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_PK PRIMARY KEY,
	LOGIN_PWD	VARCHAR2(20) CONSTRAINT	TBLPK2_LGNPW_NN	 NOT NULL,
	TEL			VARCHAR2(20)
);

-- TABLE_PK 테이블에 데이터 입력하기
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

-- NULL 값을 명시적으로 입력하기
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES(NULL, 'PWD02', '010-2345-6789');

-- NULL 값을 암시적으로 입력하기
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('PWD02', '010-2345-6789');

SELECT * FROM TABLE_PK;
SELECT * FROM TABLE_PK2;

-- # 14-5 다른 테이블과 관계를 맺는 FOREIGN KEY
/*
외래키, 외부키로도 부르는 FOREIGN KEY는 서로 다른 테이블 간 관계를 정의하는 데 사용하는 제약 조건입니다.
 */
-- EMP 테이블과 DEPT 테이블의 제약 조건 살펴보기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_OWNER, R_CONSTRAINT_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME IN ('EMP', 'DEPT');
 
-- FOREIGN KEY가 참조하는 열에 존재하지 않는 데이터 입력하기
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(9999, '홍길동', 'CLERK', '7788', TO_DATE('2017/04/30', 'YYYY/MM/DD'), 1200, NULL, 50);

-- DEPT_FK 테이블 생성하기
CREATE TABLE DEPT_FK(
	DEPTNO	NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
	DNAME	VARCHAR(14),
	LOC		VARCHAR(13)
);

-- EMP_FK 테이블 생성하기
CREATE TABLE EMP_FK(
	EMPNO		NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
	ENAME		VARCHAR(10),
	JOB			VARCHAR(9),
	MGR			NUMBER(4),
	HIREDATE	DATE,
	SAL			NUMBER(7,2),
	COMM		NUMBER(7,2),
	DEPTNO		NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK(DEPTNO)
);

-- EMP_FK 테이블에 데이터 삽입하기(DEPTNO 데이터가 아직 DEPT_FK 테이블에 없을 때)
INSERT INTO EMP_FK
VALUES(9999, 'TEST_NAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'),
		3000, NULL, 10);
	
INSERT INTO DEPT_FK
VALUES(10, 'TEST_DNAME', 'TEST_LOC');

-- DEPT_FK 테이블의 10번 부서 데이터 삭제하기
DELETE FROM DEPT_FK
 WHERE DEPTNO = 10;

SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;

-- # 14-6 데이터 형태와 범위를 정하는 CHECK
/*
CHECK 제약 조건은 열에 저장할 수 있는 값의 범위 또는 패턴을 정의할 때 사용한다.
 */
-- 테이블 생성할 때 CHECK 제약 조건 설정하기
CREATE TABLE TABLE_CHECK(
	LOGIN_ID	VARCHAR2(20) CONSTRAINT TBLCK_LOGINID_PK PRIMARY KEY,
	LOGIN_PWD	VARCHAR2(20) CONSTRAINT TBLCK_LOGINPW_CK CHECK (LENGTH(LOGIN_PWD)>3),
	TEL			VARCHAR2(20)
);

--  CHECK 제약 조건에 맞지 않는 예
INSERT INTO TABLE_CHECK
VALUES('TEST_ID', '123', '010-1234-5678');

-- CHECK 제약 조건에 맞는 예
INSERT INTO TABLE_CHECK
VALUES('TEST_ID', '1234', '010-1234-5678');

-- CHECK 제약 조건 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_CHECK%';

SELECT * FROM TABLE_CHECK;

-- #14-7 기본값을 정하는 DEFAULT
/*
제약 조건과는 별개로 특정 열에 저장할 값이 지정되지 않았을 경우에 기본값을 지정할 수 있다.
이때 사용되는게 DEFAULT 이다
 * */

-- 테이블을 생성할 때 DEFAULT 제약 조건 설정하기
CREATE TABLE TABLE_DEFAULT(
	LOGIN_ID	VARCHAR2(20) CONSTRAINT TBLCK2_LOGINID_PK PRIMARY KEY,
	LOGIN_PWD	VARCHAR2(20) DEFAULT '1234',
	TEL			VARCHAR2(20)
);

-- DEFAULT로 지정한 기본값이 입력되는 INSERT문 확인하기
INSERT INTO TABLE_DEFAULT VALUES('TEST_ID', NULL, '010-1234-5678');

INSERT INTO TABLE_DEFAULT (LOGIN_ID, TEL) VALUES('TEST_ID2', '010-1234-5678');

SELECT * FROM TABLE_DEFAULT;

-- Q1
--1
CREATE TABLE DEPT_CONST (
	DEPTNO	NUMBER(2) CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY,
	DNAME	VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ	UNIQUE,
	LOC		VARCHAR2(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL
);

--2
CREATE TABLE EMP_CONST (
	EMPNO	NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
	ENAME	VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL,
	JOB		VARCHAR2(9),
	TEL		VARCHAR2(20) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
	HIREDATE DATE,
	SAL		NUMBER(7,2) CONSTRAINT EMPCONST_SAL_CHK CHECK (SAL BETWEEN 1000 AND 9999),
	COMM	NUMBER(7,2),
	DEPTNO	NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST(DEPTNO)
);

--3
SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME IN ('EMP_CONST', 'DEPT_CONST')
ORDER BY CONSTRAINT_NAME;