-- 08-1 조인
SELECT *
  FROM EMP, DEPT
 ORDER BY EMPNO;

SELECT *
  FROM EMP, DEPT
 WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMPNO;

-- 테이블 별칭 사용
SELECT *
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO;

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO,
	   D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO;

SELECT E.EMPNO, D.DNAME
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO;

-- 08-2 조인종류
-- 등가조인(equl join)
SELECT EMPNO, ENAME, DEPTNO, DNAME, LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO;
-- 위의 프로세서가 오류가 나는 이유는 DEPTNO가 EMP, DEPT 두 테이블 모두 갖고 있기 때문이다.

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
ORDER BY D.DEPTNO, E.EMPNO;

-- WHERE절에 추가로 조건식 넣어 출력하기
SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO 
   AND SAL >=  3000;
 
SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
   AND E.SAL <= 2500
   AND E.EMPNO <= 9999
ORDER BY E.EMPNO;

-- 급여 범위를 지정하는 조건식으로 조인하기
SELECT *
  FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- 같은 테이블을 두번 사용하여 자체 조인하기
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
	   E2.EMPNO AS MGR_EMPNO,
	   E2.ENAME AS MGR_ENAME
  FROM EMP E1, EMP E2
 WHERE E1.MGR = E2.EMPNO;
 
-- 왼쪽 외부 조인 사용하기
-- 외부조인은 아우터 조인으로도 불리며 조인하려는 열에 NULL값이 있을경우에 이를 출력하고 싶을때 사용한다.
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
	   E2.EMPNO AS MGR_EMPNO,
	   E2.ENAME AS MGR_ENAME
  FROM EMP E1, EMP E2
 WHERE E1.MGR = E2.EMPNO(+) -- 왼쪽 열을 기준으로 오른쪽 열의 데이터 존재 여부에 상관없이 출력하라
ORDER BY E1.EMPNO;

-- 오른쪽 외부 조인 사용하기
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
	   E2.EMPNO AS MGR_EMPNO,
	   E2.ENAME AS MGR_ENAME
  FROM EMP E1, EMP E2
 WHERE E1.MGR(+) = E2.EMPNO
ORDER BY E1.EMPNO;

-- 08-3 SQL-99 표준 문법으로 배우는 조인
-- NATURAL JOIN을 사용하여 조인하기
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
	   DEPTNO, D.DNAME, D.LOC
  FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;

-- JOIN ~ USING을 사용하여 조인하기
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
	   DEPTNO, D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;

-- JOIN ~ ON
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
	   E.DEPTNO,
	   D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
 WHERE SAL <= 3000
ORDER BY E.DEPTNO, E.EMPNO;

-- 왼쪽 외부 조인을 SQL-99로 작성하기
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
	   E2.EMPNO AS MGR_EMPNO,
	   E2.ENAME AS MGR_ENAME
  FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

-- 오른쪽 외부 조인을 SQL-99로 작성하기
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
	   E2.EMPNO AS MGR_EMPNO,
	   E2.ENAME AS MGR_ENAME
  FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM,
	   DEPTNO, D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 WHERE SAL >= 3000
   AND E.MGR IS NOT NULL
ORDER BY DEPTNO, E.EMPNO;

-- Q1

-- SQL-99방식
-- SQL-99 이전  방식
SELECT D.DEPTNO, D.DNAME,
	   E.EMPNO, E.ENAME, E.SAL
  FROM EMP E, DEPT D
 WHERE D.DEPTNO = E.DEPTNO
   AND SAL > 2000;

-- SQL-99 이후 방식
SELECT DEPTNO, D.DNAME,
	   E.EMPNO, E.ENAME, E.SAL
  FROM EMP E NATURAL JOIN DEPT D
 WHERE SAL > 2000;

SELECT DEPTNO, D.DNAME,
	   E.EMPNO, E.ENAME, E.SAL
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 WHERE SAL > 2000;

SELECT D.DEPTNO, D.DNAME,
	   E.EMPNO, E.ENAME, E.SAL
  FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
 WHERE SAL > 2000;

-- Q2
-- SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME,
	   TRUNC(AVG(E.SAL)) AS AVG_SAL,
	   MAX(E.SAL) AS MAX_SAL,
	   MIN(E.SAL) AS MIN_SAL,
	   COUNT(*) AS CNT
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;

-- SQL-99 이후 방식
SELECT DEPTNO, D.DNAME,
	   TRUNC(AVG(E.SAL)) AS AVG_SAL,
	   MAX(E.SAL) AS MAX_SAL,
	   MIN(E.SAL) AS MIN_SAL,
	   COUNT(*) AS CNT
  FROM EMP E NATURAL JOIN DEPT D
GROUP BY DEPTNO, D.DNAME;

SELECT DEPTNO, D.DNAME,
	   TRUNC(AVG(E.SAL)) AS AVG_SAL,
	   MAX(E.SAL) AS MAX_SAL,
	   MIN(E.SAL) AS MIN_SAL,
	   COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D USING(DEPTNO)
GROUP BY DEPTNO, D.DNAME;

SELECT D.DEPTNO, D.DNAME,
	   TRUNC(AVG(E.SAL)) AS AVG_SAL,
	   MAX(E.SAL) AS MAX_SAL,
	   MIN(E.SAL) AS MIN_SAL,
	   COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
GROUP BY D.DEPTNO, D.DNAME;

-- Q3
-- SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME,
	   E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E, DEPT D
 WHERE D.DEPTNO = E.DEPTNO(+);

-- SQL-99 이후 방식
SELECT D.DEPTNO, D.DNAME,
	   E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E RIGHT OUTER JOIN DEPT D ON (E.DEPTNO = D.DEPTNO);

-- Q4
-- SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME,
	   E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO AS DEPTNO_1,
	   S.LOSAL, S.HISAL, S.GRADE AS GRADE,
	   E2.EMPNO AS MGR_EMPNO,
	   E2.ENAME AS MGR_ENAME
  FROM EMP E1, DEPT D, SALGRADE S, EMP E2
 WHERE E1.DEPTNO(+) = D.DEPTNO
   AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
   AND E1.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO, E1.EMPNO;

-- SQL-99 이후 방식
SELECT D.DEPTNO, D.DNAME,
	   E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO AS DEPTNO_1,
	   S.LOSAL, S.HISAL, S.GRADE AS GRADE,
	   E2.EMPNO AS MGR_EMPNO,
	   E2.ENAME AS MGR_ENAME
  FROM EMP E1 DEPT D, SALGRADE S, EMP E2
 WHERE E1.DEPTNO(+) = D.DEPTNO
   AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
   AND E1.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO, E1.EMPNO;

SELECT D.DEPTNO, D.DNAME,
	   E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO AS DEPTNO_1,
	   S.LOSAL, S.HISAL, S.GRADE AS GRADE,
	   E2.EMPNO AS MGR_EMPNO,
	   E2.ENAME AS MGR_ENAME
  FROM EMP E1 RIGHT OUTER JOIN DEPT D ON(E1.DEPTNO = D.DEPTNO)
  			  LEFT OUTER JOIN SALGRADE S ON(E1.SAL BETWEEN S.LOSAL AND S.HISAL)
  			  LEFT OUTER JOIN EMP E2 ON(E1.MGR = E2.EMPNO)
ORDER BY D.DEPTNO, E1.EMPNO;