-- 07-1 하나의 열에 출력 결과를 담는 다중행 함수
-- SUM 함수
SELECT SUM(SAL)
  FROM EMP;
 
SELECT SUM(COMM)
  FROM EMP;
  
SELECT SUM(DISTINCT SAL),
	   SUM(ALL SAL),
	   SUM(SAL)
  FROM EMP;
  
SELECT SUM(SAL), SUM(COMM)
  FROM EMP;
 
-- COUNT 함수
SELECT COUNT(*)
  FROM EMP;
  
SELECT COUNT(*)
  FROM EMP
 WHERE DEPTNO = 30;

SELECT COUNT(DISTINCT SAL),
	   COUNT(ALL SAL),
	   COUNT(SAL)
  FROM EMP;
  
-- NULL값은 제외하고 카운팅 된다. 
SELECT COUNT(COMM)
  FROM EMP;
 
SELECT COUNT(COMM)
  FROM EMP
 WHERE COMM IS NOT NULL;

-- MAX, MIN
SELECT MAX(SAL)
  FROM EMP
 WHERE DEPTNO = 10;

SELECT MIN(SAL)
  FROM EMP
 WHERE DEPTNO = 10;

SELECT MAX(HIREDATE)
  FROM EMP
 WHERE DEPTNO = 20;

SELECT MIN(HIREDATE)
  FROM EMP
 WHERE DEPTNO = 20;

-- AVG 함수
SELECT AVG(SAL)
  FROM EMP
 WHERE DEPTNO = 30;

SELECT AVG(DISTINCT SAL)
  FROM EMP
 WHERE DEPTNO = 30;

SELECT AVG(COMM)
  FROM EMP
 WHERE DEPTNO = 30;

-- 07-2 Group by
-- GROUP BY
SELECT AVG(SAL), '10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL), '20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL), '30' AS DEPTNO FROM EMP WHERE DEPTNO = 30;

SELECT AVG(SAL), DEPTNO
  FROM EMP
GROUP BY DEPTNO;

SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

SELECT AVG(COMM), DEPTNO
  FROM EMP
GROUP BY DEPTNO;

-- HAVING절
SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
GROUP BY DEPTNO, JOB
  HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;
-- 기본 형식에서 알 수 있듯이 Having절은 GROUP BY절이 존재할 경우 GROUP BY절 바로 다음에
-- 작성합니다. 그리고 GROUP BY절과 마찬가지로 별칭은 사용할 수 없습니다.

SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
 WHERE AVG(SAL) >= 2000
GROUP BY DEPTNO, JOB 
ORDER BY DEPTNO, JOB;
-- 출력 행을 제한하는 WHERE절에서는 그룹화된 데이터 AVG(SAL)를 제한하는 조건식을
-- 지정할 수 없다.

SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
GROUP BY DEPTNO, JOB
  HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
 WHERE SAL <= 3000
GROUP BY DEPTNO, JOB
  HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, AVG(SAL)
  FROM EMP
GROUP BY DEPTNO, JOB
  HAVING AVG(SAL) >= 500
ORDER BY DEPTNO, JOB;

-- 07-4 그룹화와 관련된 여러 함수
-- 기존 GROUP BY절만 사용한 그룹화
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
  FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

-- ROLLUP 함수
-- 명시한 열을 소그룹부터 대그룹의 순서로 각 그룹별 결과를 출력하고
-- 마지막에 총 데이터의 결과를 출력합니다.
-- ROLLUP 함수에는 그룹 함수를 지정할 수 없다.
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
  FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

-- CUBE 함수
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, COUNT(*)
  FROM EMP
GROUP BY DEPTNO, ROLLUP(JOB);

SELECT DEPTNO, JOB, COUNT(*)
  FROM EMP
GROUP BY JOB, ROLLUP(DEPTNO);

-- GROUPING SETS 함수
-- 같은 수준의 그룹화 열이 여러 개일 때 각 열별 그룹화를 통해 결과
-- 값을 출력하는데 사용한다.
SELECT DEPTNO, JOB, COUNT(*)
  FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;
-- 그룹화를 위해 지정한 열이 계층적으로 분류되지 않고
-- 각각 따로 그룹화한 후 연산을 수행했음을 알 수 있다.

-- GROUPING
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL),
	   GROUPING(DEPTNO),
	   GROUPING(JOB)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

SELECT DECODE(GROUPING(DEPTNO), 1, 'ALL_DEPT', DEPTNO) AS DEPTNO,
	   DECODE(GROUPING(JOB), 1, 'ALL_JOB', JOB) AS JOB,
	   COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

-- GROUPING_ID
SELECT DEPTNO, JOB, COUNT(*), SUM(SAL),
	   GROUPING(DEPTNO),
	   GROUPING(JOB),
	   GROUPING_ID(DEPTNO, JOB)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;
-- GROUPING ID는 이진벡터로 데이터를 보여준다.
-- 예를들어, 위의 (DEPTNO, JOB)이 둘다 그룹 집계에 활용이 되었으면 0을 반환하므로 ID값은 0이된다.
-- 하지만 두 열 전부 그룹 집계에 활용이 되지 않았으면 1을 반환하기 때문에 이진수 '11'은 10진수로 3이되어 '3'값을 반환한다.

-- LISTAGG
SELECT DEPTNO, ENAME
  FROM EMP
GROUP BY DEPTNO, ENAME;

SELECT DEPTNO,
	   LISTAGG(ENAME, ', ')
	   WITHIN GROUP(ORDER BY SAL DESC) AS ENAMES
  FROM EMP
GROUP BY DEPTNO;

-- PIVOT, UNPIVOT
SELECT DEPTNO, JOB, MAX(SAL)
  FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

SELECT *
  FROM(SELECT DEPTNO, JOB, SAL
  	   FROM EMP)
 PIVOT(MAX(SAL)
	   FOR DEPTNO IN (10, 20, 30)
	   )
ORDER BY JOB;

SELECT *
  FROM(SELECT JOB, DEPTNO, SAL
  	   FROM EMP)
 PIVOT(MAX(SAL)
 	   FOR JOB IN ('CLERK' AS CLERK,
 	   			   'SALESMAN' AS SALESMAN,
 	   			   'PRESIDENT' AS PRESIDENT,
 	   			   'MANAGER' AS MANAGER,
 	   			   'ANALYST' AS ANALYST
 	   				)
 	  )
ORDER BY DEPTNO;

-- oracle 11g 이전 버전에서 PIVOT과 같은 결과를 보기위한 예제
SELECT DEPTNO,
	   MAX(DECODE(JOB, 'CLERK', SAL)) AS "CLERK",
	   MAX(DECODE(JOB, 'SALESMAN', SAL)) AS "SALESMAN",
	   MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS "PRESIDENT",
	   MAX(DECODE(JOB, 'MANAGER', SAL)) AS "MANAGER",
	   MAX(DECODE(JOB, 'ANALYST', SAL)) AS "ANALYST"
  FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

-- UNPIVOT
SELECT *
  FROM(SELECT DEPTNO,
	  		  MAX(DECODE(JOB, 'CLERK', SAL)) AS "CLERK",
	   		  MAX(DECODE(JOB, 'SALESMAN', SAL)) AS "SALESMAN",
	   		  MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS "PRESIDENT",
	   		  MAX(DECODE(JOB, 'MANAGER', SAL)) AS "MANAGER",
	   		  MAX(DECODE(JOB, 'ANALYST', SAL)) AS "ANALYST"
		 FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO)
UNPIVOT(
	SAL FOR JOB IN (CLERK, SALESMAN, PRESIDENT, MANAGER, ANALYST))
ORDER BY DEPTNO, JOB;

-- Q1
SELECT DEPTNO,
	   FLOOR(AVG(SAL)) AS AVG_SAL,
	   MAX(SAL) AS MAX_SAL,
	   MIN(SAL) AS MIN_SAL,
	   COUNT(*) AS "사원 수"
  FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO DESC;

-- Q2
SELECT JOB, COUNT(*)
  FROM EMP
GROUP BY JOB
  HAVING COUNT(*) >= 3;
 
-- Q3
SELECT TO_CHAR(HIREDATE, 'YYYY') AS HIREDATE,
	   DEPTNO,
	   COUNT(*)
  FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO;

-- Q4
SELECT NVL2(COMM, 'O', 'X') AS EXIST_COMM,
	   COUNT(*) AS CNT
  FROM EMP
GROUP BY NVL2(COMM, 'O', 'X');

-- Q5
SELECT DEPTNO,
	   TO_CHAR(HIREDATE, 'YYYY') AS HIRE_YEAR,
	   COUNT(*) AS CNT,
	   MAX(SAL) AS MAX_SAL,
	   SUM(SAL) AS SUM_SAL,
	   AVG(SAL) AS AVG_SAL
  FROM EMP
GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY'));
ORDER BY DEPTNO;